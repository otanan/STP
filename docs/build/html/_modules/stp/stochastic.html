

<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" />
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  
  <title>stp.stochastic &mdash; STP 2019 documentation</title>
  

  
  <link rel="stylesheet" href="../../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />

  
  

  
  

  

  
  <!--[if lt IE 9]>
    <script src="../../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="../../" src="../../_static/documentation_options.js"></script>
        <script src="../../_static/jquery.js"></script>
        <script src="../../_static/underscore.js"></script>
        <script src="../../_static/doctools.js"></script>
    
    <script type="text/javascript" src="../../_static/js/theme.js"></script>

    
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="../../index.html" class="icon icon-home"> STP
          

          
          </a>

          
            
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        
        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <!-- Local TOC -->
              <div class="local-toc"></div>
            
          
        </div>
        
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../index.html">STP</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          

















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../../index.html" class="icon icon-home"></a> &raquo;</li>
        
          <li><a href="../index.html">Module code</a> &raquo;</li>
        
      <li>stp.stochastic</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <h1>Source code for stp.stochastic</h1><div class="highlight"><pre>
<span></span><span class="ch">#!/usr/bin/env python3</span>
<span class="sd">&quot;&quot;&quot;Handles generating random objects to use in various calculations.</span>

<span class="sd">**Author: Jonathan Delgado**</span>

<span class="sd">&quot;&quot;&quot;</span>

<span class="c1">######################## Imports ########################</span>


<span class="kn">import</span> <span class="nn">sys</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">scipy.linalg</span>
<span class="kn">import</span> <span class="nn">bisect</span> <span class="c1"># for binary search</span>

<span class="c1"># For ProgressBar</span>
<span class="kn">import</span> <span class="nn">stp.tools.gui</span> <span class="k">as</span> <span class="nn">gui</span>


<span class="c1">######################## Constructors ########################</span>


<span class="c1"># The random number generator to be used</span>
<span class="c1"># _RNG = np.random.default_rng(seed=0) # Seeded one for testing</span>
<span class="n">_RNG</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">default_rng</span><span class="p">()</span>
<span class="c1"># We may want to replace zeros by machine epsilon to avoid division by zero </span>
<span class="c1"># errors when calculating quantities of interest</span>
<span class="n">MACHINE_EPSILON</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">finfo</span><span class="p">(</span><span class="nb">float</span><span class="p">)</span><span class="o">.</span><span class="n">eps</span>


<div class="viewcode-block" id="rand_p"><a class="viewcode-back" href="../../index.html#stp.stochastic.rand_p">[docs]</a><span class="k">def</span> <span class="nf">rand_p</span><span class="p">(</span><span class="n">n</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">zeros</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; Creates a random probability distribution, currently implemented only </span>
<span class="sd">        with the uniform sampling.</span>
<span class="sd">    </span>
<span class="sd">        Kwargs:</span>
<span class="sd">            n (int): the dimension of the desired distribution</span>
<span class="sd">    </span>
<span class="sd">            zeros (int): the number of desired zeros to be injected into the distribution. Allows for ease of testing edge cases.</span>
<span class="sd">    </span>
<span class="sd">        Returns:</span>
<span class="sd">            (np.ndarray): the random distribution</span>
<span class="sd">    </span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Error checking for input amounts</span>
    <span class="k">if</span> <span class="n">zeros</span> <span class="o">&gt;</span> <span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Too many zeros, will not allow for normalization.&#39;</span><span class="p">)</span>
        <span class="n">sys</span><span class="o">.</span><span class="n">exit</span><span class="p">()</span>
    <span class="k">elif</span> <span class="n">zeros</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Invalid amount of zeros. Should be nonnegative.&#39;</span><span class="p">)</span>
        <span class="n">sys</span><span class="o">.</span><span class="n">exit</span><span class="p">()</span>
    <span class="c1"># Creates a random distribution of length n</span>
    <span class="n">p</span> <span class="o">=</span> <span class="n">_RNG</span><span class="o">.</span><span class="n">random</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>
    <span class="c1"># Set the first m entries equal to 0, where m is the amount of zeros </span>
        <span class="c1"># requested</span>
    <span class="k">if</span> <span class="n">zeros</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">p</span><span class="p">[:</span><span class="n">zeros</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="c1"># Shuffle the contents to avoid just having the same first entries as 0</span>
        <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">shuffle</span><span class="p">(</span><span class="n">p</span><span class="p">)</span>
    <span class="c1"># Return the distribution normalized by its 1-norm    </span>
    <span class="k">return</span> <span class="n">p</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">p</span><span class="p">)</span></div>


<div class="viewcode-block" id="rand_rate_matrix"><a class="viewcode-back" href="../../index.html#stp.stochastic.rand_rate_matrix">[docs]</a><span class="k">def</span> <span class="nf">rand_rate_matrix</span><span class="p">(</span><span class="n">n</span><span class="o">=</span><span class="mi">2</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; Generates a random, time-independent, n x n rate matrix consisting of </span>
<span class="sd">        probabilities per unit time. Column normalized.</span>
<span class="sd">    </span>
<span class="sd">        Kwargs:</span>
<span class="sd">            n (int): the number of states the matrix will correspond to. Relates to the dimensions of the matrix.</span>
<span class="sd">    </span>
<span class="sd">        Returns:</span>
<span class="sd">            (np.ndarray): the rate matrix.</span>
<span class="sd">    </span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Generates a random n x n matrix</span>
    <span class="n">W</span> <span class="o">=</span> <span class="n">_RNG</span><span class="o">.</span><span class="n">random</span><span class="p">(</span> <span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">n</span><span class="p">)</span> <span class="p">)</span>

    <span class="n">np</span><span class="o">.</span><span class="n">fill_diagonal</span><span class="p">(</span><span class="n">W</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
    <span class="c1"># Normalize the columns to sum to zero.</span>
    <span class="k">for</span> <span class="n">y</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
        <span class="n">W</span><span class="p">[</span><span class="n">y</span><span class="p">,</span> <span class="n">y</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">W</span><span class="p">[:,</span><span class="n">y</span><span class="p">])</span>

    <span class="k">return</span> <span class="n">W</span></div>


<div class="viewcode-block" id="rate_to_transition_matrix"><a class="viewcode-back" href="../../index.html#stp.stochastic.rate_to_transition_matrix">[docs]</a><span class="k">def</span> <span class="nf">rate_to_transition_matrix</span><span class="p">(</span><span class="n">W</span><span class="p">,</span> <span class="n">time_step</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; Converts a rate matrix to a transition matrix assuming a constant </span>
<span class="sd">        control parameter during the duration of time_step.</span>
<span class="sd">        </span>
<span class="sd">        Args:</span>
<span class="sd">            W (np.ndarray): the rate matrix</span>

<span class="sd">            time_step (float): the time step</span>
<span class="sd">    </span>
<span class="sd">        Returns:</span>
<span class="sd">            (np.ndarray): the transition matrix</span>
<span class="sd">    </span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">scipy</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">expm</span><span class="p">(</span><span class="n">W</span> <span class="o">*</span> <span class="n">time_step</span><span class="p">)</span></div>


<div class="viewcode-block" id="rand_transition_matrix"><a class="viewcode-back" href="../../index.html#stp.stochastic.rand_transition_matrix">[docs]</a><span class="k">def</span> <span class="nf">rand_transition_matrix</span><span class="p">(</span><span class="n">n</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">time_step</span><span class="o">=</span><span class="mf">1.0</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; Generates a random, time-independent, discrete-time, transition matrix</span>
<span class="sd">        by first generating a random rate matrix and then matrix exponentiating it to incorporate the time step as an additional parameter.</span>
<span class="sd">    </span>
<span class="sd">        Kwargs:</span>
<span class="sd">            n (int): the number of states the matrix will correspond to. Relates to the dimensions of the matrix.</span>

<span class="sd">            time_step (float): the time step: the interval of time between observations.</span>
<span class="sd">    </span>
<span class="sd">        Returns:</span>
<span class="sd">            (np.ndarray): the n x n transition matrix</span>
<span class="sd">    </span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">rate_to_transition_matrix</span><span class="p">(</span><span class="n">rand_rate_matrix</span><span class="p">(</span><span class="n">n</span><span class="p">),</span> <span class="n">time_step</span><span class="p">)</span></div>


<div class="viewcode-block" id="self_assembly_rate_matrix"><a class="viewcode-back" href="../../index.html#stp.stochastic.self_assembly_rate_matrix">[docs]</a><span class="k">def</span> <span class="nf">self_assembly_rate_matrix</span><span class="p">(</span><span class="n">energy</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">c</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">M</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">T</span><span class="o">=</span><span class="mi">1</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; Generates a self-assembly rate matrix for a 3-state system following:</span>
<span class="sd">        https://aip.scitation.org/doi/10.1063/1.3662140.</span>
<span class="sd">        </span>
<span class="sd">        Kwargs:</span>
<span class="sd">            energy (float): the negative of the &quot;optimally bound level of energy&quot;</span>

<span class="sd">            c (float): &quot;concentration-like variable&quot;</span>

<span class="sd">            M (int): the degeneracy of the misbound level</span>

<span class="sd">            T (float/function): the temperature as a float or a function which returns the temperature as a function of time. In the latter case the returned rate matrix will be a function which provides a np.ndarray as a function of time.</span>
<span class="sd">    </span>
<span class="sd">        Returns:</span>
<span class="sd">            (np.ndarray/function): the time-independent rate matrix as a numpy array in the case where the temperature is constant. Otherwise returns a function corresponding to the time-dependent rate matrix.</span>
<span class="sd">    </span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">M</span><span class="p">,</span> <span class="nb">int</span><span class="p">):</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;The degeneracy of the misbound level, M, must be an integer.&#39;</span><span class="p">)</span>
        <span class="n">sys</span><span class="o">.</span><span class="n">exit</span><span class="p">()</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="n">callable</span><span class="p">(</span><span class="n">T</span><span class="p">)</span> <span class="ow">and</span> <span class="n">T</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Must provide a nonnegative temperature.&#39;</span><span class="p">)</span>
        <span class="n">sys</span><span class="o">.</span><span class="n">exit</span><span class="p">()</span>

    <span class="k">if</span> <span class="n">callable</span><span class="p">(</span><span class="n">T</span><span class="p">):</span>
        <span class="c1"># T is a time-dependent temperature</span>
        <span class="c1"># Provide the time-dependent rate matrix</span>
        <span class="k">return</span> <span class="k">lambda</span> <span class="n">t</span> <span class="p">:</span> <span class="n">self_assembly_rate_matrix</span><span class="p">(</span><span class="n">energy</span><span class="o">=</span><span class="n">energy</span><span class="p">,</span> <span class="n">c</span><span class="o">=</span><span class="n">c</span><span class="p">,</span> <span class="n">M</span><span class="o">=</span><span class="n">M</span><span class="p">,</span> <span class="n">T</span><span class="o">=</span><span class="n">T</span><span class="p">(</span><span class="n">t</span><span class="p">))</span>

    <span class="c1">### Main body ###</span>

    <span class="n">alpha</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="n">energy</span> <span class="o">/</span> <span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">T</span><span class="p">))</span>
    <span class="n">W</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span>
        <span class="p">[</span>   <span class="o">-</span><span class="n">c</span> <span class="o">*</span> <span class="p">(</span><span class="n">M</span> <span class="o">+</span> <span class="mi">1</span><span class="p">),</span>   <span class="n">alpha</span><span class="p">,</span>      <span class="n">alpha</span><span class="o">**</span><span class="mi">2</span>    <span class="p">],</span>
        <span class="p">[</span>   <span class="n">c</span> <span class="o">*</span> <span class="n">M</span><span class="p">,</span>          <span class="o">-</span><span class="n">alpha</span><span class="p">,</span>     <span class="mi">0</span>           <span class="p">],</span>
        <span class="p">[</span>   <span class="n">c</span><span class="p">,</span>              <span class="mi">0</span><span class="p">,</span>          <span class="o">-</span><span class="n">alpha</span><span class="o">**</span><span class="mi">2</span>   <span class="p">]</span>
    <span class="p">])</span>

    <span class="k">return</span> <span class="n">W</span></div>


<div class="viewcode-block" id="self_assembly_transition_matrix"><a class="viewcode-back" href="../../index.html#stp.stochastic.self_assembly_transition_matrix">[docs]</a><span class="k">def</span> <span class="nf">self_assembly_transition_matrix</span><span class="p">(</span><span class="n">energy</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">c</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">M</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">T</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">time_step</span><span class="o">=</span><span class="mi">1</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; Generates a self-assembly, discrete time, transition matrix for a </span>
<span class="sd">        3-state system following: https://aip.scitation.org/doi/10.1063/1.3662140. Done assuming any external control parameter is fixed for the duration of the time_step. This matrix is step dependent, so conversions will be done to time to calculate the current temperature.</span>
<span class="sd">    </span>
<span class="sd">        Kwargs:</span>
<span class="sd">            energy (float): the negative of the &quot;optimally bound level of energy&quot;</span>

<span class="sd">            c (float): &quot;concentration-like variable&quot;</span>

<span class="sd">            M (int): the degeneracy of the misbound level</span>

<span class="sd">            T (float/function): the temperature as a float or a function which returns the temperature as a function of time. In the latter case the returned transition matrix will be a function which provides a np.ndarray as a function of time. This external control parameter will be fixed for the duration of the time_step.</span>

<span class="sd">            time_step (float): the time step</span>
<span class="sd">    </span>
<span class="sd">    </span>
<span class="sd">        Returns:</span>
<span class="sd">            (np.ndarray/function): the transition matrix</span>
<span class="sd">    </span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">callable</span><span class="p">(</span><span class="n">T</span><span class="p">):</span>
        <span class="c1"># Convert n to time.</span>
        <span class="c1"># This also serves to fix the temperature between observations to change</span>
            <span class="c1"># the control parameter discretely.</span>
        <span class="n">old_T</span> <span class="o">=</span> <span class="n">T</span>
        <span class="n">T</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">n</span> <span class="p">:</span> <span class="n">old_T</span><span class="p">(</span><span class="n">n</span> <span class="o">*</span> <span class="n">time_step</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">rate_to_transition_matrix</span><span class="p">(</span>
            <span class="n">self_assembly_rate_matrix</span><span class="p">(</span><span class="n">energy</span><span class="o">=</span><span class="n">energy</span><span class="p">,</span> <span class="n">c</span><span class="o">=</span><span class="n">c</span><span class="p">,</span> <span class="n">M</span><span class="o">=</span><span class="n">M</span><span class="p">,</span> <span class="n">T</span><span class="o">=</span><span class="n">T</span><span class="p">),</span>
            <span class="n">time_step</span>
        <span class="p">)</span></div>


<span class="c1">######################## Probability Operations ########################</span>


<div class="viewcode-block" id="step"><a class="viewcode-back" href="../../index.html#stp.stochastic.step">[docs]</a><span class="k">def</span> <span class="nf">step</span><span class="p">(</span><span class="n">matrix</span><span class="p">,</span> <span class="n">p</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; Evolves a probability distribution one step forward by computing the </span>
<span class="sd">        matrix multiplication between matrix and p. In the case of the matrix being a rate matrix the output is the time-derivative of p.</span>
<span class="sd">        </span>
<span class="sd">        Args:</span>
<span class="sd">            matrix (np.ndarray): the transition or rate matrix</span>

<span class="sd">            p (np.ndarray): the marginal distribution</span>
<span class="sd">    </span>
<span class="sd">        Returns:</span>
<span class="sd">            (np.ndarray): the evolved marginal</span>
<span class="sd">    </span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">matmul</span><span class="p">(</span><span class="n">matrix</span><span class="p">,</span> <span class="n">p</span><span class="p">)</span></div>
    

<div class="viewcode-block" id="get_stationary_distribution"><a class="viewcode-back" href="../../index.html#stp.stochastic.get_stationary_distribution">[docs]</a><span class="k">def</span> <span class="nf">get_stationary_distribution</span><span class="p">(</span><span class="n">matrix</span><span class="p">,</span> <span class="n">discrete</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; Calculates the stationary distribution of a transition or rate matrix. </span>
<span class="sd">        Credit: https://stackoverflow.com/questions/31791728/python-code-explanation-for-stationary-distribution-of-a-markov-chain.</span>
<span class="sd">        </span>
<span class="sd">        Args:</span>
<span class="sd">            matrix (np.ndarray/function): the transition or rate matrix</span>
<span class="sd">    </span>
<span class="sd">        Kwargs:</span>
<span class="sd">            discrete (bool): True if the provided matrix is a discrete time transition matrix, False if the provided matrix is a continuous time rate matrix</span>
<span class="sd">    </span>
<span class="sd">        Returns:</span>
<span class="sd">            (np.ndarray/function): the limiting distribution (as a function of time in the case where the matrix is too)</span>
<span class="sd">    </span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">callable</span><span class="p">(</span><span class="n">matrix</span><span class="p">):</span>
        <span class="c1"># Return the limiting distribution as a function of time</span>
        <span class="k">return</span> <span class="k">lambda</span> <span class="n">t</span> <span class="p">:</span> <span class="n">get_stationary_distribution</span><span class="p">(</span><span class="n">matrix</span><span class="p">(</span><span class="n">t</span><span class="p">),</span> <span class="n">discrete</span><span class="o">=</span><span class="n">discrete</span><span class="p">)</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="n">discrete</span><span class="p">:</span>
        <span class="c1"># Use the simplified method for the rate matrix, not as robust</span>
            <span class="c1"># Make sure to check output</span>
        <span class="n">_</span><span class="p">,</span> <span class="n">eigenvec</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">eig</span><span class="p">(</span><span class="n">matrix</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Returning experimental right eigenvector to the rate matrix. Always check the vector is correct!&#39;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">eigenvec</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">])</span>

    <span class="n">S</span><span class="p">,</span> <span class="n">U</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">eig</span><span class="p">(</span><span class="n">matrix</span><span class="p">)</span>
    <span class="c1"># Added the need to take the real part to avoid +0j added to each term</span>
    <span class="c1"># and raising a complex error</span>
    <span class="c1"># Added absolute value since I was occasionally getting the negative p</span>
    <span class="n">stationary</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">absolute</span><span class="p">(</span>
        <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">U</span><span class="p">[:,</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">S</span> <span class="o">-</span> <span class="mf">1.</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mf">1e-8</span><span class="p">)[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]]</span><span class="o">.</span><span class="n">flat</span><span class="p">)</span><span class="o">.</span><span class="n">real</span>
    <span class="p">)</span>
    <span class="k">return</span> <span class="n">stationary</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">stationary</span><span class="p">)</span></div>


<div class="viewcode-block" id="get_path_probability"><a class="viewcode-back" href="../../index.html#stp.stochastic.get_path_probability">[docs]</a><span class="k">def</span> <span class="nf">get_path_probability</span><span class="p">(</span><span class="n">R</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="n">path</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; Calculates the probability of observing a provided path using the a</span>
<span class="sd">        (potentially time-inhomogeneous) transition matrix, the initial marginal distribution, and the path itself.</span>
<span class="sd">        </span>
<span class="sd">        Args:</span>
<span class="sd">            R (function/np.ndarray): the transition matrix. A function of the observation step if the matrix is time-inhomogeneous. That is, R = R(n). In which case Pr( x &lt;- y ) = R(1)[x,y] * p[y]. Provide a numpy matrix in the case of a time-homogeneous transition matrix.</span>

<span class="sd">            p (np.ndarray): the marginal distribution.</span>

<span class="sd">            path (list/np.ndarray): the path.</span>
<span class="sd">    </span>
<span class="sd">        Returns:</span>
<span class="sd">            (float): the probability of observing this path.</span>
<span class="sd">    </span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Check if R is written as a numpy matrix, if so, convert it to a function</span>
        <span class="c1"># of the observation step that simply returns the constant matrix.</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">R</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">):</span>
        <span class="n">matrix</span> <span class="o">=</span> <span class="n">R</span>
        <span class="n">R</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">n</span><span class="p">:</span> <span class="n">matrix</span>

    <span class="c1"># Comprehension to collect transition probabilities for vectored product</span>
    <span class="n">total_jump_prob</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span>
        <span class="n">R</span><span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)[</span><span class="n">path</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">],</span> <span class="n">path</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span> <span class="nb">len</span><span class="p">(</span><span class="n">path</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span> <span class="p">)</span>
    <span class="p">])</span><span class="o">.</span><span class="n">prod</span><span class="p">()</span>

    <span class="k">return</span> <span class="n">total_jump_prob</span> <span class="o">*</span> <span class="n">p</span><span class="p">[</span><span class="n">path</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span></div>


<span class="c1">######################## Path space sampling ########################</span>


<div class="viewcode-block" id="complete_path_space"><a class="viewcode-back" href="../../index.html#stp.stochastic.complete_path_space">[docs]</a><span class="k">def</span> <span class="nf">complete_path_space</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">path_length</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; Generates the entire path space as a matrix with each row corresponding </span>
<span class="sd">        to a path and each column corresponding to an observation step.</span>
<span class="sd">        </span>
<span class="sd">        Args:</span>
<span class="sd">            n (int): the number of states in the state space</span>

<span class="sd">            path_length (int): the length of each path</span>
<span class="sd">    </span>
<span class="sd">        Returns:</span>
<span class="sd">            (np.ndarray): the entire path space. Will be a matrix of size: n^path_length x path_length.</span>
<span class="sd">    </span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">paths</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="n">num_paths</span> <span class="o">=</span> <span class="n">n</span><span class="o">**</span><span class="n">path_length</span>

    <span class="n">bar</span> <span class="o">=</span> <span class="n">gui</span><span class="o">.</span><span class="n">ProgressBar</span><span class="p">(</span><span class="n">num_paths</span><span class="p">,</span> <span class="n">width</span><span class="o">=</span><span class="mi">300</span><span class="p">,</span> <span class="n">title</span><span class="o">=</span><span class="s1">&#39;Generating path space...&#39;</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">num_paths</span><span class="p">):</span>
        <span class="n">path</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">base_repr</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">base</span><span class="o">=</span><span class="n">n</span><span class="p">)</span>
        <span class="n">path</span> <span class="o">=</span> <span class="p">(</span> <span class="n">path_length</span> <span class="o">-</span> <span class="nb">len</span><span class="p">(</span><span class="n">path</span><span class="p">)</span> <span class="p">)</span><span class="o">*</span><span class="s1">&#39;0&#39;</span> <span class="o">+</span> <span class="n">path</span>
        <span class="n">paths</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
            <span class="c1"># Convert the number from decimal to base n.</span>
            <span class="c1"># This will be in a string format, turn each digit into a separate</span>
                <span class="c1"># int in a list, this will be a path.</span>
                <span class="p">[</span> <span class="nb">int</span><span class="p">(</span><span class="n">state</span><span class="p">)</span> <span class="k">for</span> <span class="n">state</span> <span class="ow">in</span> <span class="n">path</span> <span class="p">]</span>
            <span class="p">)</span>

        <span class="n">bar</span><span class="o">.</span><span class="n">update</span><span class="p">()</span>

    <span class="n">bar</span><span class="o">.</span><span class="n">finish</span><span class="p">()</span>

    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">paths</span><span class="p">)</span></div>


<div class="viewcode-block" id="KMC"><a class="viewcode-back" href="../../index.html#stp.stochastic.KMC">[docs]</a><span class="k">def</span> <span class="nf">KMC</span><span class="p">(</span><span class="n">W</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="n">num_paths</span><span class="p">,</span> <span class="n">final_time</span><span class="p">,</span> <span class="n">time_step</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">discrete</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">degenerate_threshold</span><span class="o">=</span><span class="mf">0.985</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; A Rejection-free Kinetic Monte Carlo (KMC) algorithm for simulating </span>
<span class="sd">        the time evolution of a system, where some processes can occur with known rates W = W(t). From: https://en.wikipedia.org/wiki/Kinetic_Monte_Carlo.</span>
<span class="sd">        </span>
<span class="sd">        Args:</span>
<span class="sd">            W (np.ndarray/function): rate matrix for np.ndarray. If function is provided then W is the function of time that provides a rate matrix (W = W(t)) for each moment in time. Will be used to implement driven systems. If W is just a rate matrix then W is just the time-homogeneous rate matrix.</span>

<span class="sd">            p (np.ndarray): the initial marginal distribution.</span>

<span class="sd">            num_paths (int): the number of paths to sample.</span>

<span class="sd">            final_time (float): the final time.</span>
<span class="sd">    </span>
<span class="sd">        Kwargs:</span>
<span class="sd">            time_step (float): the interval between changing of rate matrix (changing of control parameter), and the delay between observations.</span>

<span class="sd">            discrete (bool): True if the the simulation is for discrete time and hence the control parameter will be switched accordingly. If False the algorithm will be done for continuous time and will return the time series too.</span>

<span class="sd">            degenerate_threshold (float): the fraction of paths that we require to be unique. If not satisfied KMC will be run again with an increased threshold.</span>
<span class="sd">    </span>
<span class="sd">        Returns:</span>
<span class="sd">            (np.ndarray): matrix of paths sampled via KMC.</span>
<span class="sd">    </span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1">#------------- Helper functions -------------#</span>


    <span class="k">def</span> <span class="nf">_KMC_jump</span><span class="p">(</span><span class="n">cumulatives</span><span class="p">,</span> <span class="n">state</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Helper function which takes cumulatives, a state, and generates </span>
<span class="sd">            the next likely jump via the KMC algorithm and the time it takes to observe the jump. Useful for discretizing the KMC.</span>
<span class="sd">            </span>
<span class="sd">            Args:</span>
<span class="sd">                cumulatives (np.ndarray): the KMC&#39;s cumulatives.</span>

<span class="sd">                state (int): the current state.</span>
<span class="sd">        </span>
<span class="sd">            Returns:</span>
<span class="sd">                (2-tuple): (next_state, delta time)</span>
<span class="sd">        </span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># https://en.wikipedia.org/wiki/Kinetic_Monte_Carlo.</span>
        <span class="c1"># The cumulative relevant to the current state</span>
        <span class="n">relevant_cumulative</span> <span class="o">=</span> <span class="n">cumulatives</span><span class="p">[:,</span> <span class="n">state</span><span class="p">]</span>
        <span class="n">u</span> <span class="o">=</span> <span class="n">_RNG</span><span class="o">.</span><span class="n">uniform</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
        <span class="n">scaled_total_rate</span> <span class="o">=</span> <span class="n">u</span> <span class="o">*</span> <span class="n">cumulatives</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">state</span><span class="p">]</span>
        <span class="n">next_state</span> <span class="o">=</span> <span class="n">bisect</span><span class="o">.</span><span class="n">bisect_left</span><span class="p">(</span><span class="n">relevant_cumulative</span><span class="p">,</span> <span class="n">scaled_total_rate</span><span class="p">)</span>
        <span class="n">u</span> <span class="o">=</span> <span class="n">_RNG</span><span class="o">.</span><span class="n">uniform</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
        <span class="n">jump_time</span> <span class="o">=</span> <span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">u</span><span class="p">)</span> <span class="o">/</span> <span class="n">relevant_cumulative</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>

        <span class="k">return</span> <span class="n">next_state</span><span class="p">,</span> <span class="n">jump_time</span>


    <span class="k">def</span> <span class="nf">_KMC_discrete</span><span class="p">(</span><span class="n">W</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="n">num_paths</span><span class="p">,</span> <span class="n">final_time</span><span class="p">,</span> <span class="n">time_step</span><span class="o">=</span><span class="mi">1</span><span class="p">):</span>

        <span class="c1">#------------- Initialization -------------#</span>

        <span class="c1"># Read off the size of the state space.</span>
        <span class="n">n</span> <span class="o">=</span> <span class="n">W</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">state_options</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>
        <span class="c1"># Read off the path length for the full time series observations given </span>
            <span class="c1"># the final time and the delay between observations.</span>
        <span class="c1"># For final_time, time_step, and path_length, the relationship is:</span>
        <span class="c1"># time_step * (path_length - 1) = final_time, which implies that</span>
        <span class="n">path_length</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">final_time</span> <span class="o">/</span> <span class="n">time_step</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>

        <span class="c1"># Initialize the matrix storing the paths</span>
        <span class="n">paths</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">full</span><span class="p">(</span> <span class="p">(</span><span class="n">num_paths</span><span class="p">,</span> <span class="n">path_length</span><span class="p">),</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="s1">&#39;int64&#39;</span> <span class="p">)</span>
        <span class="c1"># Set the first column of the matrix to be initial state weighted by p.</span>
        <span class="n">paths</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">_RNG</span><span class="o">.</span><span class="n">choice</span><span class="p">(</span><span class="n">state_options</span><span class="p">,</span> <span class="n">p</span><span class="o">=</span><span class="n">p</span><span class="p">,</span> <span class="n">size</span><span class="o">=</span><span class="n">num_paths</span><span class="p">)</span>

        <span class="c1"># Fill each column</span>
        <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">path_length</span><span class="p">):</span>
            <span class="c1"># This will find the current time of the control parameter to fix</span>
                <span class="c1"># the rate matrix since this is discrete time.</span>
            <span class="n">current_time</span> <span class="o">=</span> <span class="n">k</span> <span class="o">*</span> <span class="n">time_step</span>
            <span class="c1"># Fix the rate matrix</span>
            <span class="n">current_W</span> <span class="o">=</span> <span class="n">W</span><span class="p">(</span><span class="n">current_time</span><span class="p">)</span>

            <span class="c1">#------------- Main algorithm -------------#</span>

            <span class="c1"># We need to remove the normalization for the algorithm and just </span>
                <span class="c1"># look at the positive rates.</span>
            <span class="n">posW</span> <span class="o">=</span> <span class="n">current_W</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
            <span class="n">np</span><span class="o">.</span><span class="n">fill_diagonal</span><span class="p">(</span><span class="n">posW</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
            <span class="c1"># Matrix of partial sums, last one being the total rate</span>
            <span class="c1"># Each row corresponds to the same final index for the partial sum</span>
            <span class="c1"># Each column corresponds to which rates were summed together</span>
            <span class="n">cumulatives</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span> <span class="p">[</span> <span class="p">[</span> 
                <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">posW</span><span class="p">[:</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">x</span><span class="p">])</span>
                <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>
            <span class="p">]</span>   <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>
            <span class="p">]</span> <span class="p">)</span><span class="o">.</span><span class="n">T</span>

            <span class="c1"># Run through the path matrix.</span>
            <span class="k">for</span> <span class="n">path</span> <span class="ow">in</span> <span class="n">paths</span><span class="p">:</span>
                <span class="n">current_state</span> <span class="o">=</span> <span class="n">path</span><span class="p">[</span><span class="n">k</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span>
                <span class="c1"># The state we are currently in is the last nonnegative </span>
                    <span class="c1"># element of our path list (since the path matrix is</span>
                    <span class="c1"># initialized with -1)</span>
                <span class="c1"># current_state = path[path &gt;= 0][-1]</span>
                
                <span class="n">total_jump_times</span> <span class="o">=</span> <span class="mi">0</span>
                <span class="c1"># Prepare for the while loop</span>
                <span class="n">next_state</span> <span class="o">=</span> <span class="n">current_state</span>
                <span class="c1"># Keep evolving the state until it fits what would be observed</span>
                    <span class="c1"># in a discrete time process.</span>
                <span class="k">while</span> <span class="n">total_jump_times</span> <span class="o">&lt;</span> <span class="n">time_step</span><span class="p">:</span>
                    <span class="n">potential_jump</span><span class="p">,</span> <span class="n">jump_time</span> <span class="o">=</span> <span class="n">_KMC_jump</span><span class="p">(</span><span class="n">cumulatives</span><span class="p">,</span> <span class="n">next_state</span><span class="p">)</span>
                    
                    <span class="c1"># Note that if the next jump takes longer than our </span>
                        <span class="c1"># time_step we won&#39;t observe it. Since we will</span>
                        <span class="c1"># make the measurement before this happens.</span>
                    <span class="k">if</span> <span class="n">total_jump_times</span> <span class="o">+</span> <span class="n">jump_time</span> <span class="o">&gt;=</span> <span class="n">time_step</span><span class="p">:</span>
                        <span class="k">break</span>

                    <span class="n">total_jump_times</span> <span class="o">+=</span> <span class="n">jump_time</span>
                    <span class="n">next_state</span> <span class="o">=</span> <span class="n">potential_jump</span>

                <span class="n">path</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">next_state</span>

        <span class="c1">### Degenerate paths check ###</span>
        <span class="c1"># Check for degenerate paths and sample again if needed.</span>
        <span class="n">paths</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">paths</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">paths</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">/</span> <span class="n">num_paths</span> <span class="o">&lt;</span> <span class="n">degenerate_threshold</span><span class="p">:</span>
            <span class="c1"># Generate a rate matrix of perturbations</span>
            <span class="n">deltaW</span> <span class="o">=</span> <span class="n">rand_rate_matrix</span><span class="p">(</span><span class="n">n</span><span class="p">)</span> <span class="o">/</span> <span class="mi">100</span>
            <span class="n">Wprime</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">t</span> <span class="p">:</span> <span class="n">W</span><span class="p">(</span><span class="n">t</span><span class="p">)</span> <span class="o">+</span> <span class="n">deltaW</span>

            <span class="c1"># Run KMC again with an increased degeneracy threshold and </span>
                <span class="c1"># a perturbed rate matrix.</span>
            <span class="n">new_paths</span> <span class="o">=</span> <span class="n">KMC</span><span class="p">(</span><span class="n">Wprime</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="n">num_paths</span><span class="p">,</span> <span class="n">final_time</span><span class="p">,</span> <span class="n">time_step</span><span class="o">=</span><span class="n">time_step</span><span class="p">,</span> <span class="n">discrete</span><span class="o">=</span><span class="n">discrete</span><span class="p">,</span> <span class="n">degenerate_threshold</span><span class="o">=</span><span class="n">degenerate_threshold</span><span class="o">-</span><span class="mf">10E-9</span><span class="p">)</span>

            <span class="c1"># Combine the path data</span>
            <span class="n">paths</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">((</span><span class="n">paths</span><span class="p">,</span> <span class="n">new_paths</span><span class="p">)),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span> <span class="p">)</span>
            
        <span class="c1"># Return only the requested number of paths (in case we have extras</span>
            <span class="c1"># from previous degeneracies)</span>
        <span class="k">return</span> <span class="n">paths</span><span class="p">[:</span><span class="n">num_paths</span><span class="p">]</span>

    <span class="c1">#------------- Body -------------#</span>

    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">W</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">):</span>
        <span class="c1"># Hold the rate matrix in memory.</span>
        <span class="n">constW</span> <span class="o">=</span> <span class="n">W</span>
        <span class="c1"># Let the time-dependent rate matrix just be the constant matrix.</span>
        <span class="n">W</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">t</span><span class="p">:</span> <span class="n">constW</span>

    <span class="k">if</span> <span class="n">discrete</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_KMC_discrete</span><span class="p">(</span><span class="n">W</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="n">num_paths</span><span class="p">,</span> <span class="n">final_time</span><span class="p">,</span> <span class="n">time_step</span><span class="o">=</span><span class="n">time_step</span><span class="p">)</span>

    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Continuous time KMC has not been implemented yet.&#39;</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Exiting...&#39;</span><span class="p">)</span>
    <span class="n">sys</span><span class="o">.</span><span class="n">exit</span><span class="p">()</span></div>


<div class="viewcode-block" id="direct_sampling"><a class="viewcode-back" href="../../index.html#stp.stochastic.direct_sampling">[docs]</a><span class="k">def</span> <span class="nf">direct_sampling</span><span class="p">(</span><span class="n">R</span><span class="p">,</span> <span class="n">p</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; Samples the path space directly to reflect the dynamics given by the </span>
<span class="sd">        initial marginal and the transition matrix.</span>
<span class="sd">        </span>
<span class="sd">        Args:</span>
<span class="sd">            arg1 (arg1 type): arg1 description.</span>
<span class="sd">    </span>
<span class="sd">        Kwargs:</span>
<span class="sd">            karg1 (arg1 type): arg1 description.</span>
<span class="sd">    </span>
<span class="sd">    </span>
<span class="sd">        Returns:</span>
<span class="sd">            (None): none</span>
<span class="sd">    </span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Direct sampling has not been implemented yet.&#39;</span><span class="p">)</span></div>
    

<span class="c1">######################## Entry Code ########################</span>


<span class="k">def</span> <span class="nf">main</span><span class="p">():</span>
    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;stochastic.py&#39;</span><span class="p">)</span>
    
    
<span class="k">if</span> <span class="vm">__name__</span> <span class="o">==</span> <span class="s1">&#39;__main__&#39;</span><span class="p">:</span>
    <span class="n">main</span><span class="p">()</span>
</pre></div>

           </div>
           
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>
        &#169; Copyright 2021, Jonathan Delgado.

    </p>
  </div>
    
    
    
    Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    
    provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>
        </div>
      </div>

    </section>

  </div>
  

  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>